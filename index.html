<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, viewport-fit=cover">
    <title>çˆ±çš„å®ˆæŠ¤ - èªä»”èŒè¶£ç‰ˆ</title>
    <style>
        body {
            margin: 0;
            padding: 0;
            background: linear-gradient(to bottom, #ff9a9e, #fad0c4, #fecfef);
            overflow: hidden;
            font-family: "PingFang SC", "Microsoft YaHei", sans-serif;
            user-select: none;
            -webkit-user-select: none;
            touch-action: none;
        }

        /* é®ç½©å±‚ */
        .overlay-screen {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(255, 255, 255, 0.9);
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            z-index: 100;
            color: #d63384;
            padding: 20px;
            box-sizing: border-box;
            backdrop-filter: blur(5px);
            transition: opacity 0.3s;
        }

        h1 {
            font-size: 32px;
            margin-bottom: 10px;
            background: linear-gradient(to right, #ff758c, #ff7eb3);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            text-align: center;
            font-weight: 800;
        }

        h2 { font-size: 28px; margin-bottom: 20px; color: #ff758c; }

        p { font-size: 16px; color: #666; text-align: center; margin-bottom: 30px; line-height: 1.6; }

        .btn-group {
            display: flex;
            flex-direction: column;
            gap: 15px;
            width: 80%;
            max-width: 300px;
        }

        button {
            padding: 15px 10px;
            font-size: 18px;
            border: none;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            box-shadow: 0 4px 15px rgba(255, 105, 180, 0.2);
            transition: transform 0.1s;
            color: white;
            outline: none;
            position: relative;
            overflow: hidden;
        }

        button:active { transform: scale(0.96); }

        .btn-easy { background: linear-gradient(45deg, #ff9a9e, #fecfef); color: #c71585; }
        .btn-normal { background: linear-gradient(45deg, #a18cd1, #fbc2eb); color: white; }
        .btn-hard { background: linear-gradient(45deg, #ff5858, #f09819); color: white; }

        .btn-restart { background: #fff; border: 2px solid #ff758c; color: #ff758c; margin-top: 20px; width: 60%;}

        #pause-btn {
            position: absolute;
            top: 15px;
            right: 15px;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background: rgba(255, 255, 255, 0.6);
            border: 2px solid #fff;
            color: #ff758c;
            font-size: 18px;
            display: flex;
            justify-content: center;
            align-items: center;
            cursor: pointer;
            pointer-events: auto;
            z-index: 60;
            box-shadow: 0 2px 5px rgba(0,0,0,0.1);
        }

        .btn-resume { background: linear-gradient(45deg, #4facfe, #00f2fe); color: white; }
        .btn-quit { background: #fff; border: 2px solid #999; color: #999; }

        #ui-layer {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #d63384;
            font-weight: bold;
            font-size: 18px;
            pointer-events: none;
            z-index: 50;
            text-shadow: 1px 1px 0px rgba(255,255,255,0.8);
        }

        .floating-text {
            position: absolute;
            color: #ff4081;
            font-weight: bold;
            font-size: 18px; /* å­—ä½“ç¨å¾®è°ƒå°é…åˆå°é±¼ */
            pointer-events: none;
            animation: floatUp 1.5s ease-out forwards;
            text-shadow: 1px 1px 2px white;
            white-space: nowrap;
        }

        @keyframes floatUp {
            0% { opacity: 1; transform: translateY(0) scale(1); }
            100% { opacity: 0; transform: translateY(-40px) scale(1.1); }
        }
    </style>
</head>
<body>

<div id="particles-container"></div>

<div id="ui-layer" style="display:none;">
    <div>æ‹çˆ±æŒ‡æ•°: <span id="score">0</span> â¤ï¸</div>
    <div style="font-size: 12px; opacity: 0.8; margin-top:5px; color:#666">æˆ‘ä»¬åœ¨ä¸€èµ·: <span id="size-display">1</span> å¤©</div>
</div>

<button id="pause-btn" style="display:none;" onclick="pauseGame()">â¸</button>

<!-- å¼€å§‹ç•Œé¢ -->
<div id="start-screen" class="overlay-screen">
    <h1>ğŸ’– çˆ±çš„å®ˆæŠ¤ ğŸ’–</h1>
    <p>æˆ‘ä»¬å˜æˆäº†è¿·ä½ å°é±¼<br>è™½ç„¶ä¸–ç•Œå¾ˆå¤§ï¼Œå›°éš¾å¾ˆå¤š<br>ä½†èªä»”ä¼šä¸€ç›´é™ªç€ä½ é•¿å¤§~</p>

    <div class="btn-group">
        <button class="btn-easy" onclick="startGame('easy')">ğŸ° ç”œèœœçº¦ä¼š (ç®€å•)</button>
        <button class="btn-normal" onclick="startGame('normal')">ğŸ  å¹¸ç¦æ—¥å¸¸ (æ™®é€š)</button>
        <button class="btn-hard" onclick="startGame('hard')">ğŸ›¡ï¸ å®ˆæŠ¤ä¸€ç”Ÿ (å›°éš¾)</button>
    </div>
</div>

<!-- æš‚åœç•Œé¢ -->
<div id="pause-screen" class="overlay-screen" style="display: none;">
    <h2>æ¸¸æˆæš‚åœ</h2>
    <div class="btn-group">
        <button class="btn-resume" onclick="resumeGame()">â–¶ ç»§ç»­çˆ±</button>
        <button class="btn-quit" onclick="quitGameFromPause()">âœ– ä¼‘æ¯ä¸€ä¸‹ (ç»“æŸ)</button>
    </div>
</div>

<!-- ç»“æŸç•Œé¢ -->
<div id="game-over-screen" class="overlay-screen" style="display: none;">
    <h2 style="font-size: 28px; color: #ff5858;">åˆ«æ€•ï¼Œèªä»”åœ¨å‘¢</h2>
    <p id="death-reason" style="font-size: 16px;">å¦‚æœä¸å¼€å¿ƒäº†ï¼Œæˆ‘æ¥å“„ä½ ~</p>
    <p style="font-size: 20px;">æ”¶è·çˆ±å¿ƒ: <span id="final-score" style="color: #ff4081; font-weight:bold;">0</span></p>
    <button class="btn-restart" onclick="showStartScreen()">å†çˆ±ä¸€æ¬¡</button>
</div>

<canvas id="gameCanvas"></canvas>

<script>
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');

    const uiLayer = document.getElementById('ui-layer');
    const pauseBtn = document.getElementById('pause-btn');
    const startScreen = document.getElementById('start-screen');
    const gameOverScreen = document.getElementById('game-over-screen');
    const pauseScreen = document.getElementById('pause-screen');

    const scoreEl = document.getElementById('score');
    const sizeEl = document.getElementById('size-display');
    const finalScoreEl = document.getElementById('final-score');
    const deathReasonEl = document.getElementById('death-reason');
    const particlesContainer = document.getElementById('particles-container');

    const LOVE_WORDS = ["çˆ±ä½ ", "æŠ±æŠ±", "æƒ³ä½ ", "äº²äº²", "ä¹–å®", "çœŸæ£’", "å¥½å¯çˆ±", "ç¾ç¾å“’", "è´´è´´", "Love U"];

    let animationId;
    let score = 0;
    let gameRunning = false;
    let isPaused = false;
    let frameCount = 0;
    let currentDifficulty = {};

    // éš¾åº¦é…ç½®
    const DIFFICULTY_SETTINGS = {
        'easy': { spawnRate: 50, speedMultiplier: 0.6, weights: [0.6, 0.2, 0.2, 0, 0, 0, 0] },
        'normal': { spawnRate: 45, speedMultiplier: 0.9, weights: [0.4, 0.2, 0.2, 0.1, 0.05, 0.05, 0] },
        'hard': { spawnRate: 30, speedMultiplier: 1.2, weights: [0.25, 0.2, 0.2, 0.15, 0.1, 0.05, 0.05] }
    };

    function resizeCanvas() {
        canvas.width = window.innerWidth;
        canvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resizeCanvas);
    resizeCanvas();

    const input = { x: canvas.width / 2, y: canvas.height / 2 };
    function handleInput(x, y) {
        if(!isPaused && gameRunning) {
            input.x = x;
            input.y = y;
        }
    }
    window.addEventListener('mousemove', e => handleInput(e.clientX, e.clientY));
    canvas.addEventListener('touchstart', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});
    canvas.addEventListener('touchmove', e => { e.preventDefault(); handleInput(e.touches[0].clientX, e.touches[0].clientY); }, {passive:false});

    // ================= æ¸¸æˆç±»å®šä¹‰ =================

    // 1. å¥³æœ‹å‹ (ç²‰è‰²å°é±¼) - åˆå§‹å˜å¾—æ›´å°
    class Player {
        constructor() {
            this.x = canvas.width / 2;
            this.y = canvas.height / 2;
            this.radius = 12;  // ä»20æ”¹ä¸º12ï¼Œæ›´åŠ å°å·§
            this.angle = 0;
        }
        update() {
            const dx = input.x - this.x;
            const dy = input.y - this.y;
            if (Math.hypot(dx, dy) > 5) {
                this.angle = Math.atan2(dy, dx);
                this.x += dx * 0.08;
                this.y += dy * 0.08;
            }
        }
        draw() {
            // ç²‰è‰²å…‰ç¯
            ctx.save();
            ctx.translate(this.x, this.y);
            ctx.beginPath();
            ctx.fillStyle = 'rgba(255, 182, 193, 0.3)';
            ctx.arc(0, 0, this.radius * 1.6 + Math.sin(frameCount * 0.1) * 2, 0, Math.PI * 2);
            ctx.fill();
            ctx.restore();

            drawCuteFish(ctx, this.x, this.y, this.radius, this.angle, '#FF69B4', true, null);
        }
    }

    // 2. èªä»” (è“è‰²å°é±¼) - ä¹Ÿå˜å°
    class Guardian {
        constructor() {
            this.x = canvas.width / 2 - 40;
            this.y = canvas.height / 2;
            this.radius = 10; // ä»18æ”¹ä¸º10
            this.angle = 0;
        }
        update(targetX, targetY) {
            const targetX_delayed = targetX - Math.cos(player.angle) * 30; // è·ç¦»ç¼©çŸ­
            const targetY_delayed = targetY - Math.sin(player.angle) * 30;
            const dx = targetX_delayed - this.x;
            const dy = targetY_delayed - this.y;
            this.angle = Math.atan2(dy, dx);
            this.x += dx * 0.06;
            this.y += dy * 0.06;
        }
        draw() {
            drawCuteFish(ctx, this.x, this.y, this.radius, this.angle, '#00BFFF', false, 'èªä»”');
        }
    }

    // 3. ç‰©å“ä¸æ•Œäºº (æ–°å¢å¤šç§ç±»å‹)
    class Item {
        constructor(diffSettings) {
            const rand = Math.random();
            const w = diffSettings.weights; // 7ä¸ªæƒé‡ä½
            let typeIdx = 0;
            let sum = 0;
            for(let i=0; i<w.length; i++) {
                sum += w[i];
                if(rand < sum) { typeIdx = i; break; }
            }

            // === ä¸°å¯Œçš„ç”Ÿç‰©é…ç½® ===
            const configs = [
                // --- çˆ±å¿ƒç±» ---
                { type: 'heart', r: 8,  color: '#ff4081', score: 10, speed: [1, 2], name: 'å°æƒŠå–œ' },
                { type: 'heart', r: 15, color: '#ff0055', score: 20, speed: [1.5, 2.5], name: 'å¤§ç¤¼ç‰©' },

                // --- éšœç¢ç±» (ç”Ÿæ´»ä¸­çš„æŒ‘æˆ˜) ---
                // 1. å°æ‘©æ“¦ (ç»¿è‰²ï¼Œå°è€Œå¿«)
                { type: 'bad', subtype: 'normal', r: 14, color: '#8BC34A', score: 0, speed: [2, 3.5], name: 'å°æ‘©æ“¦' },
                // 2. åæƒ…ç»ª (ç°è‰²ï¼Œä¸­ç­‰)
                { type: 'bad', subtype: 'normal', r: 25, color: '#9E9E9E', score: 0, speed: [1.5, 2.5], name: 'åæƒ…ç»ª' },
                // 3. çƒ‚æ¡ƒèŠ± (ç´«è‰²ï¼Œå°–é”ï¼Œé€Ÿåº¦å¿«)
                { type: 'bad', subtype: 'sharp',  r: 30, color: '#9C27B0', score: 0, speed: [3, 4],   name: 'çƒ‚æ¡ƒèŠ±' },
                // 4. åŠ ç­ (æ·±è‰²æ–¹å—ï¼Œå¤§è€Œæ…¢ï¼ŒBOSSçº§)
                { type: 'bad', subtype: 'block',  r: 45, color: '#546E7A', score: 0, speed: [1, 2],   name: 'åŠ ç­' },
                // 5. å†·æˆ˜ (å†°è“è‰²ï¼Œå¤§ï¼Œéš¾èº²)
                { type: 'bad', subtype: 'ice',    r: 65, color: '#00BCD4', score: 0, speed: [3, 5],   name: 'å†·æˆ˜' }
            ];

            const c = configs[typeIdx];
            this.type = c.type;
            this.subtype = c.subtype || 'normal';
            this.radius = c.r;
            this.color = c.color;
            this.score = c.score;
            this.name = c.name;

            this.y = Math.random() * canvas.height;
            this.speed = (Math.random()*(c.speed[1]-c.speed[0]) + c.speed[0]) * diffSettings.speedMultiplier;

            const side = Math.random() < 0.5 ? 'left' : 'right';
            if (side === 'left') {
                this.x = -this.radius * 2;
                this.vx = this.speed;
            } else {
                this.x = canvas.width + this.radius * 2;
                this.vx = -this.speed;
            }
        }
        update() { this.x += this.vx; }
        draw() {
            ctx.save();
            ctx.translate(this.x, this.y);

            if (this.type === 'heart') {
                drawHeart(ctx, 0, 0, this.radius, this.color);
            } else {
                // æ ¹æ® subtype ç»˜åˆ¶ä¸åŒå½¢çŠ¶çš„æ•Œäºº
                if (this.vx < 0) ctx.scale(-1, 1);
                ctx.fillStyle = this.color;

                if (this.subtype === 'sharp') {
                    // çƒ‚æ¡ƒèŠ±ï¼šä¸‰è§’å½¢/å°–åˆºçŠ¶
                    ctx.beginPath();
                    ctx.moveTo(this.radius, 0);
                    ctx.lineTo(-this.radius, -this.radius * 0.8);
                    ctx.lineTo(-this.radius * 0.5, 0);
                    ctx.lineTo(-this.radius, this.radius * 0.8);
                    ctx.fill();
                    // é‚ªæ¶çš„çœ¼ç›
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(0, -this.radius*0.2, this.radius*0.2, 0, Math.PI*2); ctx.fill();
                }
                else if (this.subtype === 'block') {
                    // åŠ ç­ï¼šåœ†è§’çŸ©å½¢/æ–¹å¤´é±¼
                    ctx.beginPath();
                    ctx.roundRect(-this.radius*1.2, -this.radius*0.8, this.radius*2.4, this.radius*1.6, 5);
                    ctx.fill();
                    // ç–²æƒ«çš„çœ¼ç›
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(this.radius*0.5, -this.radius*0.2, this.radius*0.2, 0, Math.PI*2); ctx.fill();
                    ctx.strokeStyle = '#333';
                    ctx.lineWidth = 2;
                    ctx.beginPath(); ctx.moveTo(this.radius*0.2, -this.radius*0.4); ctx.lineTo(this.radius*0.8, -this.radius*0.4); ctx.stroke();
                }
                else {
                    // æ™®é€šåœ†å½¢é±¼ (æ‘©æ“¦ã€åæƒ…ç»ªã€å†·æˆ˜)
                    ctx.beginPath();
                    ctx.ellipse(0, 0, this.radius * 1.2, this.radius, 0, 0, Math.PI*2);
                    ctx.fill();
                    // å°¾å·´
                    ctx.beginPath();
                    ctx.moveTo(-this.radius, 0);
                    ctx.lineTo(-this.radius*1.8, -this.radius*0.8);
                    ctx.lineTo(-this.radius*1.8, this.radius*0.8);
                    ctx.fill();

                    // è¡¨æƒ…
                    ctx.fillStyle = 'white';
                    ctx.beginPath(); ctx.arc(this.radius*0.4, -this.radius*0.3, this.radius*0.25, 0, Math.PI*2); ctx.fill();
                    ctx.fillStyle = 'black';
                    ctx.beginPath(); ctx.arc(this.radius*0.45, -this.radius*0.3, this.radius*0.08, 0, Math.PI*2); ctx.fill();

                    // çœ‰æ¯›
                    ctx.strokeStyle = 'white';
                    ctx.lineWidth = 2;
                    ctx.beginPath();
                    if(this.subtype === 'ice') { // å†·æˆ˜ï¼šå¹³çœ‰æ¯›
                        ctx.moveTo(this.radius*0.1, -this.radius*0.5);
                        ctx.lineTo(this.radius*0.7, -this.radius*0.5);
                    } else { // æ„¤æ€’çœ‰æ¯›
                        ctx.moveTo(this.radius*0.1, -this.radius*0.6);
                        ctx.lineTo(this.radius*0.7, -this.radius*0.4);
                    }
                    ctx.stroke();
                }
            }
            ctx.restore();
        }
    }

    // æ ¸å¿ƒç»˜å›¾å‡½æ•°
    function drawCuteFish(ctx, x, y, r, angle, color, hasEyelashes, text) {
        ctx.save();
        ctx.translate(x, y);
        ctx.rotate(angle);

        ctx.fillStyle = color;
        ctx.beginPath();
        ctx.ellipse(0, 0, r * 1.5, r, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        const tailX = -r * 1.2;
        ctx.moveTo(tailX, 0);
        ctx.quadraticCurveTo(tailX - r, -r, tailX - r, 0);
        ctx.quadraticCurveTo(tailX - r, r, tailX, 0);
        ctx.fill();

        ctx.fillStyle = 'white';
        ctx.beginPath(); ctx.arc(r * 0.6, -r * 0.3, r * 0.35, 0, Math.PI * 2); ctx.fill();
        ctx.fillStyle = '#333';
        ctx.beginPath(); ctx.arc(r * 0.7, -r * 0.3, r * 0.15, 0, Math.PI * 2); ctx.fill();

        if (hasEyelashes) {
            ctx.strokeStyle = '#333'; ctx.lineWidth = 1.5; ctx.beginPath();
            ctx.moveTo(r*0.6, -r*0.6); ctx.lineTo(r*0.5, -r*0.8);
            ctx.moveTo(r*0.7, -r*0.65); ctx.lineTo(r*0.7, -r*0.9);
            ctx.moveTo(r*0.8, -r*0.6); ctx.lineTo(r*0.9, -r*0.8);
            ctx.stroke();
        }

        if (text) {
            ctx.fillStyle = 'white';
            const fontSize = text.length > 1 ? r * 0.6 : r * 0.7;
            ctx.font = `bold ${fontSize}px "Microsoft YaHei", sans-serif`;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(text, -r * 0.1, 0);
        }

        ctx.fillStyle = 'rgba(255,0,0,0.2)';
        ctx.beginPath(); ctx.arc(r * 0.6, r * 0.1, r * 0.2, 0, Math.PI * 2); ctx.fill();
        ctx.restore();
    }

    function drawHeart(ctx, x, y, r, color) {
        ctx.fillStyle = color;
        ctx.beginPath();
        const topCurveHeight = r * 0.8;
        ctx.moveTo(0, r * 0.6);
        ctx.bezierCurveTo(0, 0, -r, 0, -r, -topCurveHeight);
        ctx.bezierCurveTo(-r, -r * 1.6, 0, -r * 1.6, 0, -topCurveHeight);
        ctx.bezierCurveTo(0, -r * 1.6, r, -r * 1.6, r, -topCurveHeight);
        ctx.bezierCurveTo(r, 0, 0, 0, 0, r * 0.6);
        ctx.fill();
        ctx.fillStyle = 'rgba(255,255,255,0.4)';
        ctx.beginPath(); ctx.arc(-r*0.3, -r*0.8, r*0.15, 0, Math.PI*2); ctx.fill();
    }

    function spawnFloatingText(text, x, y) {
        const el = document.createElement('div');
        el.className = 'floating-text';
        el.innerText = text;
        el.style.left = x + 'px';
        el.style.top = y + 'px';
        particlesContainer.appendChild(el);
        setTimeout(() => el.remove(), 1500);
    }

    // ================= æ¸¸æˆæ§åˆ¶ =================

    let player, guardian;
    let items = [];

    function init(difficultyKey) {
        currentDifficulty = DIFFICULTY_SETTINGS[difficultyKey];
        player = new Player();
        guardian = new Guardian();
        items = [];
        score = 0;
        scoreEl.innerText = score;
        sizeEl.innerText = 1;
        frameCount = 0;
        isPaused = false;
        input.x = canvas.width / 2;
        input.y = canvas.height / 2;
    }

    function gameLoop() {
        if (!gameRunning) return;
        if (isPaused) return;

        ctx.clearRect(0, 0, canvas.width, canvas.height);

        player.update();
        guardian.update(player.x, player.y);

        guardian.draw();
        player.draw();

        frameCount++;
        if (frameCount % currentDifficulty.spawnRate === 0) {
            items.push(new Item(currentDifficulty));
        }

        for (let i = items.length - 1; i >= 0; i--) {
            let item = items[i];
            item.update();
            item.draw();

            if (item.x < -100 || item.x > canvas.width + 100) {
                items.splice(i, 1);
                continue;
            }

            const dist = Math.hypot(player.x - item.x, player.y - item.y);
            if (dist < player.radius + item.radius) {
                if (item.type === 'heart') {
                    items.splice(i, 1);
                    score += item.score;
                    scoreEl.innerText = score;
                    const word = LOVE_WORDS[Math.floor(Math.random() * LOVE_WORDS.length)];
                    spawnFloatingText(word, player.x, player.y - 30);
                    if (player.radius < 60) {
                        player.radius += 0.5;
                        guardian.radius += 0.4;
                        // ä¿®æ­£å¤©æ•°æ˜¾ç¤ºé€»è¾‘ï¼Œå› ä¸ºåˆå§‹åŠå¾„å˜å°äº†
                        sizeEl.innerText = Math.floor(player.radius - 11);
                    }
                } else {
                    if (player.radius > item.radius) {
                        items.splice(i, 1);
                        spawnFloatingText("æ‰“è´¥" + item.name + "!", player.x, player.y - 30);
                        score += 5;
                        scoreEl.innerText = score;
                    } else {
                        deathReasonEl.innerText = `è¢«"${item.name}"ç»Šå€’äº†...`;
                        endGame();
                    }
                }
            }
        }

        animationId = requestAnimationFrame(gameLoop);
    }

    function startGame(difficulty) {
        startScreen.style.display = 'none';
        gameOverScreen.style.display = 'none';
        pauseScreen.style.display = 'none';
        uiLayer.style.display = 'block';
        pauseBtn.style.display = 'flex';
        init(difficulty);
        gameRunning = true;
        gameLoop();
    }

    function pauseGame() {
        if (!gameRunning) return;
        isPaused = true;
        cancelAnimationFrame(animationId);
        pauseScreen.style.display = 'flex';
    }

    function resumeGame() {
        isPaused = false;
        pauseScreen.style.display = 'none';
        gameLoop();
    }

    function quitGameFromPause() {
        pauseScreen.style.display = 'none';
        deathReasonEl.innerText = "ä¼‘æ¯å¥½äº†å—ï¼Ÿéšæ—¶éƒ½å¯ä»¥å›æ¥å“¦~";
        endGame();
    }

    function showStartScreen() {
        startScreen.style.display = 'flex';
        gameOverScreen.style.display = 'none';
        uiLayer.style.display = 'none';
        pauseBtn.style.display = 'none';
        pauseScreen.style.display = 'none';
        ctx.clearRect(0, 0, canvas.width, canvas.height);
    }

    function endGame() {
        gameRunning = false;
        isPaused = false;
        cancelAnimationFrame(animationId);
        finalScoreEl.innerText = score;
        pauseBtn.style.display = 'none';
        gameOverScreen.style.display = 'flex';
    }

    showStartScreen();

</script>
</body>
</html>